{"version":3,"sources":["components/Result.js","App.js","serviceWorker.js","index.js"],"names":["Result","props","starColour","element","favouritedStatus","favouriteFunc","react_default","a","createElement","className","fa","onClick","color","title","dangerouslySetInnerHTML","__html","ReactHtmlParser","body","App","state","results","favourites","query","queryStatus","findResults","_this","refs","searchValue","value","toLowerCase","setState","matchingResults","Data","forEach","keywords","includes","favourited","push","length","handleKeyPress","e","key","handleInputChange","target","toggleFavourite","updateFavourites","filter","item","concat","Object","toConsumableArray","renderResults","_this$state","map","src_components_Result","id","renderFavourites","favouritesStatus","_this2","this","_this$state2","onKeyPress","onChange","type","ref","placeholder","name","autoComplete","io","size","transform","Fragment","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.90d8098d.chunk.js","sourcesContent":["import React from \"react\";\nimport ReactHtmlParser from \"react-html-parser\";\nimport { FaStar } from \"react-icons/fa\";\nimport \"./Result.css\";\n\nconst Result = props => {\n  const { element, favouritedStatus, favouriteFunc } = props;\n  let starColour;\n  //set colour of star based on the elements favouritedStatus\n  favouritedStatus ? (starColour = \"#24995c\") : (starColour = \"#aaaaaa\");\n\n  return (\n    <div className=\"resultContainer\">\n      <FaStar\n        className=\"resultStar\"\n        onClick={() => favouriteFunc(element)}\n        color={starColour}\n      />\n      <p className=\"resultTitle\">{element.title}</p>\n      <div\n        className=\"resultBody\"\n        dangerouslySetInnerHTML={{ __html: ReactHtmlParser(element.body) }}\n      />\n    </div>\n  );\n};\n\nexport default Result;\n","import React, { Component } from \"react\";\nimport \"./App.css\";\nimport Data from \"./data.json\";\nimport Result from \"./components/Result\";\nimport { IoIosSearch } from \"react-icons/io\";\n\nclass App extends Component {\n\n  state = {\n    results: [],\n    favourites: [],\n    query: \"\",\n    queryStatus: \"blank\"\n  };\n\n  findResults = () => {\n    //value inside search input\n    const query = this.refs.searchValue.value.toLowerCase();\n\n    if (query === \"\") {\n      //query search is blank\n      this.setState({ queryStatus: \"failed\" });\n    } else {\n      //find results that match the element's keywords\n      const matchingResults = [];\n      Data.forEach(element => {\n        const keyWords = element.keywords;\n        if (keyWords.includes(query)) {\n          //add 'favourited' property to element for favouriting functionality\n          element.favourited = false;\n          matchingResults.push(element);\n        }\n      });\n\n      //check if search produced any results. if successful store results in state. \n      //if unsuccessful store \"failed\" in state\n      matchingResults.length === 0\n        ? this.setState({ queryStatus: \"failed\" })\n        : this.setState({ results: matchingResults });\n    }\n  };\n\n  handleKeyPress = e => {\n    //check if user presses \"Enter\" key while focused on input\n    //if so, search for results\n    if (e.key === \"Enter\") {\n      this.findResults();\n    }\n  };\n\n  handleInputChange = e => {\n    //track value of input inside 'query' state\n    this.setState({ query: e.target.value });\n\n    //if input is blank, remove all matches\n    if (e.target.value === \"\") {\n      this.setState({\n        results: [],\n        queryStatus: \"blank\"\n      });\n    }\n  };\n\n  //toggles status of \"favourited\" for clicked element\n  toggleFavourite = element => {\n    const { favourites } = this.state\n    if (element.favourited) {\n      element.favourited = false;\n      //create new favourites array without the selected element\n      const updateFavourites = favourites.filter(\n        item => item !== element\n      );\n      //update state to remove selected element\n      this.setState({\n        favourites: updateFavourites\n      });\n    } else {\n      element.favourited = true;\n      //add selected element to state \"favourites\" array \n      this.setState({\n        favourites: [...favourites, element]\n      });\n    }\n  };\n\n  renderResults = () => {\n    const { results, favourites } = this.state;\n    let favourited;\n    //loop through \"results\" and render all results\n    return results.map(element => {\n      //check if the element is already favourited\n      if (favourites.includes(element)) {\n        element.favourited = true;\n      }\n\n      //check favourited status of element to determine stlying\n      element.favourited ? (favourited = true) : (favourited = false);\n\n      return (\n        <Result\n          element={element}\n          id={element.id}\n          favouriteFunc={this.toggleFavourite}\n          favouritedStatus={favourited}\n        />\n      );\n    });\n  };\n\n  renderFavourites = () => {\n    const { favourites } = this.state;\n    //loop through \"favourites\" array and render all favourited elements\n    return favourites.map(element => (\n      <Result\n        element={element}\n        id={element.id}\n        favouriteFunc={this.toggleFavourite}\n        favouritedStatus={true}\n      />\n    ));\n  };\n\n  //determine which message to render regarding search status & results\n  favouritesStatus = () => {\n    const { queryStatus } = this.state;\n    switch (queryStatus) {\n      case \"blank\":\n        return <p className=\"textContainer\">Search Toronto's Solid Waste Management Services!</p>;\n      case \"failed\":\n        return <p className=\"textContainer\">No results! :(</p>;\n      default:\n        return null;\n    }\n  };\n\n  render() {\n    const { results, favourites } = this.state;\n    return (\n      <div className=\"App\">\n        <div className=\"headerContainer\">\n          <p>Toronto Waste Lookup</p>\n        </div>\n        <div className=\"bodyContainer\">\n          <div className=\"searchBarContainer\">\n            <input\n              onKeyPress={this.handleKeyPress}\n              onChange={this.handleInputChange}\n              className=\"searchBarInput\"\n              type=\"text\"\n              ref=\"searchValue\"\n              placeholder=\"Search... (ex: Takeout)\"\n              name=\"search\"\n              autoComplete=\"off\"\n            />\n            <a className=\"searchBarButton\" onClick={() => this.findResults()}>\n              <IoIosSearch\n                size={33}\n                transform=\"scale(-1, 1)\"\n                color={\"#ffffff\"}\n                className=\"searchBarButtonIcon\"\n              />\n            </a>\n          </div>\n          <div className=\"resultsContainer\">\n            {results.length > 0 ? (\n              <>\n                {this.renderResults()}\n                {favourites.length > 1 ? null : (\n                  <>\n                    <p className=\"favouritesTitle\">Favourites</p>\n                    <p className=\"favouritesHint\">\n                      Add more than 1 items to display favourites\n                    </p>\n                  </>\n                )}\n              </>\n            ) : (\n              this.favouritesStatus()\n            )}\n            {favourites.length > 1 ? (\n              <>\n                <p className=\"favouritesTitle\">Favourites</p>\n                {this.renderFavourites()}\n              </>\n            ) : null}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}